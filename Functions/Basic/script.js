// ...args
{
    function sumAll(...args) { // args — имя массива
        let sum = 0;

        for (let arg of args) sum += arg;

        return sum;
    }

    console.log( sumAll(1) ); // 1
    console.log( sumAll(1, 2) ); // 3
    console.log( sumAll(1, 2, 3) ); // 6
}
// Переменная "arguments"
{
    /*
    Хотя arguments похож на массив, и его тоже можно перебирать, это всё же не массив.
    Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).

    Стрелочные функции не имеют "arguments"
    Если мы обратимся к arguments из стрелочной функции, то получим аргументы внешней «нормальной» функции.
    Как мы помним, у стрелочных функций нет собственного this.
     */
    function showName() {
        console.log( arguments.length );
        console.log( arguments[0] );
        console.log( arguments[1] );

        // Объект arguments можно перебирать
        // for (let arg of arguments) alert(arg);
    }

    // Вывод: 2, Юлий, Цезарь
    showName("Юлий", "Цезарь");

    // Вывод: 1, Илья, undefined (второго аргумента нет)
    showName("Илья");

    function f() {
        let showArg = () => console.log(arguments[0]);
        showArg(2);
    }

    f(1); // 1
}
// Оператор расширения
{
    let arr = [3, 5, 1];

    console.log( Math.max(arr) ); // NaN
    // Math.max ожидает получить список чисел, а не один массив
    // Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

    let arr1 = [3, 5, 1];

    console.log( Math.max(...arr1) ); // 5 (оператор "раскрывает" массив в список аргументов)

    let arr2 = [1, -2, 3, 4];
    let arr3 = [8, 3, -8, 1];

    console.log( Math.max(...arr2, ...arr3) ); // 8
}
{
    // Оператор расширения можно использовать и для слияния массивов:
    let arr = [3, 5, 1];
    let arr2 = [8, 9, 15];

    let merged = [0, ...arr, 2, ...arr2];

    console.log(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

    // оператор расширения подойдёт для того, чтобы превратить строку в массив символов:
    let str = "Привет";

    console.log( [...str] ); // П,р,и,в,е,т
    /*
    Результат аналогичен [...str].

    Но между Array.from(obj) и [...obj] есть разница:

    Array.from работает как с псевдомассивами, так и с итерируемыми объектами
    Оператор расширения работает только с итерируемыми объектами
    Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
     */
}
// Замыкание — функция, которая ссылается на свободные переменные в своей области видимости.
{
    /*
    В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект,
    называемый лексическим окружением LexicalEnvironment.
    Объект лексического окружения состоит из двух частей:
        - Environment Record – объект, в котором как свойства хранятся все локальные переменные
          (а также некоторая другая информация, такая как значение this).
        - Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

     "Переменная" – это просто свойство специального внутреннего объекта: Environment Record.
     «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

     В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда,
     когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.

     При запуске функции для неё автоматически создаётся новое лексическое окружение,
     для хранения локальных переменных и параметров вызова.

     Итак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):

        - внутреннее лексическое окружение соответствует текущему выполнению say.
          В нём находится одна переменная name, аргумент функции. Мы вызываем say("John"), так что значение переменной name равно "John".

        - Внешнее лексическое окружение – это глобальное лексическое окружение.
          В нём находятся переменная phrase и сама функция.

    У внутреннего лексического окружения есть ссылка outer на внешнее.
    Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении,
    затем во внешнем, затем в следующем и так далее, до глобального.

    Функция получает текущее значение внешних переменных, то есть, их последнее значение
    Старые значения переменных нигде не сохраняются. Когда функция хочет получить доступ к переменной,
    она берёт её текущее значение из своего или внешнего лексического окружения.

    Один вызов – одно лексическое окружение

    Функция называется «вложенной», когда она создаётся внутри другой функции.
    вложенная функция может быть возвращена: либо в качестве свойства нового объекта
    (если внешняя функция создаёт объект с методами), либо сама по себе.
    И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.
     */

    // функция-конструктор возвращает новый объект
    function User(name) {

        // методом объекта становится вложенная функция
        this.sayHi = function() {
            console.log(name);
        };
    }

    let user = new User("John");
    user.sayHi(); // у кода метода "sayHi" есть доступ к внешней переменной "name"



    function makeCounter() {
        let count = 0;

        return function() {
            return count++; // есть доступ к внешней переменной "count"
        };
    }

    let counter = makeCounter();

    console.log( counter() ); // 0
    console.log( counter() ); // 1
    console.log( counter() ); // 2

    /*
    Для примера выше порядок будет такой:
        1 Локальные переменные вложенной функции…
        2 Переменные внешней функции…
        3 И так далее, пока не будут достигнуты глобальные переменные.
    В этом примере count будет найден на шаге 2. Когда внешняя переменная модифицируется, она изменится там, где была найдена.
    Значит, count++ найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит.
    Как если бы у нас было let count = 1.

    Для каждого вызова makeCounter() создаётся новое лексическое окружение функции, со своим собственным count.
    Так что, получившиеся функции counter – независимы.
     */

    function makeCounterTest() {
        let count = 0;
        return function() {
            return count++;
        };
    }

    let counter1 = makeCounterTest();
    let counter2 = makeCounterTest();

    console.log( counter1() ); // 0
    console.log( counter1() ); // 1

    console.log( counter2() ); // 0 (независимо)

    /*
    Все функции «при рождении» получают скрытое свойство [[Environment]],
    которое ссылается на лексическое окружение места, где они были созданы.
     */


    // IIFE что означает функцию, запускаемую сразу после объявления.

    (function() {

        let message = "Hello";

        console.log(message); // Hello

    })();
}
// summ
{
    function sum(a) {

        return function(b) {
            return a + b; // берёт "a" из внешнего лексического окружения
        };

    }

    console.log( sum(1)(2) ); // 3
    console.log( sum(5)(-1) ); // 4
}
// function.name - name of fuction
{
    // В JavaScript функции – это объекты.

    function sayHi() {
        console.log("Hi");
    }

    console.log(sayHi.name); // sayHi
}
{
    let sayHi = function() {
        console.log("Hi");
    };

    console.log(sayHi.name); // sayHi (есть имя!)
}
{
    function f(sayHi = function() {}) {
        console.log(sayHi.name); // sayHi (работает!)
    }

    f();
}
{
    let user = {

        sayHi() {
            // ...
        },

        sayBye: function() {
            // ...
        }

    }

    console.log(user.sayHi.name); // sayHi
    console.log(user.sayBye.name); // sayBye
}
// function.length - count of arguments
{
    function f1(a) {}
    function f2(a, b) {}
    function many(a, b, ...more) {} // здесь как бы «не считается»

    console.log(f1.length); // 1
    console.log(f2.length); // 2
    console.log(many.length); // 2
}
// new Function([arg1, arg2, ...argN], functionBody);
{
    // функция создаётся полностью «на лету» из строки, переданной во время выполнения.
    let sum = new Function('a', 'b', 'return a + b');
    console.log( sum(1, 2) ); // 3

    let sayHi = new Function('console.log("Hello")');
    sayHi(); // Hello
}
// new Function and closure
{
    /*
    Но когда функция создаётся с использованием new Function, в её [[Environment]]
    записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
    Поэтому такая функция имеет доступ только к глобальным переменным.
     */
    function getFunc() {
        let value = "test";

        let func = new Function('console.log(value)');

        return func;
    }

    getFunc()(); // ошибка: value не определено
}